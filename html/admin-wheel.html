<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V√≤ng Quay Admin - HC Eco System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="image/jpeg" href="../assets/img/logo.jpg" />
    <style>
        * {
            font-family: 'Times New Roman', Times, serif;
        }
        body {
            position: relative;
            
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 50%, #fff9c4 100%);
        }
        #wheel-graphic {
            transition: transform 4.5s cubic-bezier(0.23, 1, 0.32, 1);
            transform-origin: 50% 50%;
        }
        .pointer {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 18px solid transparent;
            border-right: 18px solid transparent;
            border-top: 80px solid #ff6b35;
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4));
            z-index: 20;
        }
        .pointer::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 14px solid transparent;
            border-right: 14px solid transparent;
            border-top: 70px solid #ffd93d;
            left: -14px;
            top: -70px;
        }
        .result-box {
            background: linear-gradient(135deg, #f1f8e9 0%, #dcedc8 100%);
            border: 3px solid #7cb342;
            transition: all 0.3s ease;
            min-height: 180px;
        }
        .result-box.show-result {
            animation: resultPulse 0.6s ease-in-out;
            border-color: #558b2f;
            box-shadow: 0 0 25px rgba(124, 179, 66, 0.6);
        }
        @keyframes resultPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        .spin-button {
            background: linear-gradient(135deg, #7cb342 0%, #8bc34a 50%, #9ccc65 100%);
            box-shadow: 0 6px 20px rgba(124, 179, 66, 0.4);
            transition: all 0.3s ease;
        }
        .spin-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(124, 179, 66, 0.6);
        }
        .spin-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    
        /* Canvas container cho neural network */
        #neural-network-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        /* ƒê·∫£m b·∫£o content n·∫±m tr√™n background */
        main, header, footer {
            position: relative;
            z-index: 1;
        }
        
        /* Sections trong su·ªët ho√†n to√†n - ch·ªâ c√≥ vi·ªÅn bao quanh */
        section {
            position: relative;
            background: rgba(255, 255, 255, 0.08) !important;
            backdrop-filter: blur(2px) !important;
            -webkit-backdrop-filter: blur(2px) !important;
            border: 2px solid rgba(34, 197, 94, 0.30) !important;
            border-radius: 16px;
            margin: 2rem auto;
            max-width: 100%;
            width: min(1200px, calc(100% - 2.5rem));
            box-shadow: 0 4px 6px rgba(34, 197, 94, 0.10);
        }
        
        body[data-theme="dark"] section {
            background: rgba(15, 23, 42, 0.55) !important;
            border-color: rgba(74, 222, 128, 0.40) !important;
            box-shadow: 0 4px 6px rgba(74, 222, 128, 0.15);
        }
        
        /* Hero section - trong su·ªët v·ªõi vi·ªÅn */
        section.bg-gradient-to-br {
            background: rgba(22, 163, 74, 0.15) !important;
            backdrop-filter: blur(3px) !important;
            border: 2px solid rgba(34, 197, 94, 0.50) !important;
            border-radius: 20px;
        }
        
        /* C√°c section c√≥ bg-white/bg-gray - trong su·ªët v·ªõi vi·ªÅn */
        section.bg-white,
        section.bg-gray-50,
        section.bg-gray-100,
        section.bg-gray-900,
        section[class*="bg-white"],
        section[class*="bg-gray"] {
            background: rgba(255, 255, 255, 0.06) !important;
            backdrop-filter: blur(2px) !important;
            -webkit-backdrop-filter: blur(2px) !important;
            border: 2px solid rgba(34, 197, 94, 0.30) !important;
            border-radius: 16px;
        }
        
        body[data-theme="dark"] section.bg-white,
        body[data-theme="dark"] section.bg-gray-50,
        body[data-theme="dark"] section.bg-gray-100,
        body[data-theme="dark"] section.bg-gray-900,
        body[data-theme="dark"] section[class*="bg-white"],
        body[data-theme="dark"] section[class*="bg-gray"] {
            background: rgba(15, 23, 42, 0.45) !important;
            border-color: rgba(74, 222, 128, 0.40) !important;
        }
        
        /* Override t·∫•t c·∫£ c√°c div c√≥ bg-white/bg-gray - trong su·ªët */
        main section > div[class*="bg-white"],
        main section > div[class*="bg-gray"],
        section div[class*="bg-white"],
        section div[class*="bg-gray"] {
            background: transparent !important;
        }
        
        /* C√°c card b√™n trong - trong su·ªët v·ªõi vi·ªÅn */
        div.bg-white,
        div[class*="bg-white"],
        .bg-white.dark\:bg-gray-800,
        .dark\:bg-gray-800 {
            background: rgba(255, 255, 255, 0.15) !important;
            backdrop-filter: blur(2px) !important;
            border: 1.5px solid rgba(34, 197, 94, 0.40) !important;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(34, 197, 94, 0.10);
        }
        
        body[data-theme="dark"] div.bg-white,
        body[data-theme="dark"] div[class*="bg-white"],
        body[data-theme="dark"] .bg-white.dark\:bg-gray-800,
        body[data-theme="dark"] .dark\:bg-gray-800 {
            background: rgba(17, 24, 39, 0.25) !important;
            backdrop-filter: blur(2px) !important;
            border-color: rgba(74, 222, 128, 0.50) !important;
            box-shadow: 0 2px 4px rgba(74, 222, 128, 0.15);
        }
        
        /* Article cards - trong su·ªët v·ªõi vi·ªÅn */
        article[class*="bg-"],
        article.bg-gradient-to-br {
            background: rgba(240, 253, 244, 0.20) !important;
            backdrop-filter: blur(3px) !important;
            border: 2px solid rgba(34, 197, 94, 0.40) !important;
            border-radius: 20px;
            box-shadow: 0 4px 8px rgba(34, 197, 94, 0.15);
        }
        
        body[data-theme="dark"] article[class*="bg-"],
        body[data-theme="dark"] article.bg-gradient-to-br {
            background: rgba(31, 41, 55, 0.30) !important;
            border-color: rgba(74, 222, 128, 0.50) !important;
            box-shadow: 0 4px 8px rgba(74, 222, 128, 0.20);
        }
        
        /* Container v√† c√°c div wrapper c≈©ng trong su·ªët */
        .container {
            background: transparent !important;
        }
        
        /* Main content trong su·ªët */
        main {
            background: transparent !important;
        }
        
        /* ƒê·∫£m b·∫£o c√°c ph·∫ßn tr·ªëng hi·ªÉn th·ªã n·ªÅn ƒë·ªông */
        body > *:not(header):not(footer) {
            background: transparent !important;
        }
        
        /* Header gi·ªØ nguy√™n trong su·ªët */
        header {
            background: rgba(255, 255, 255, 0.90) !important;
            backdrop-filter: blur(10px) !important;
        }
        
        /* Footer gi·ªØ nguy√™n n·ªÅn ƒëen */
        footer {
            background: #000000 !important;
        }
        
        /* Quy t·∫Øc: Ch·ªâ √°p d·ª•ng vi·ªÅn cho ch·ªØ l·ªõn (heading) */
        h1, h2, h3 {
            -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.2);
            text-stroke: 0.5px rgba(0, 0, 0, 0.2);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        /* Ngo·∫°i l·ªá: Gi·ªØ ch·ªØ tr·∫Øng cho c√°c tr∆∞·ªùng h·ª£p sau */
        /* 1. Footer - n·ªÅn ƒëen */
        footer .text-white {
            color: #f3f4f6 !important;
        }
        
        /* 2. Button/Badge v·ªõi n·ªÅn m√†u ƒë·∫≠m */
        .bg-green-600 .text-white,
        .bg-orange-500 .text-white,
        .bg-blue-500 .text-white,
        .bg-purple-600 .text-white,
        .bg-teal-600 .text-white,
        .bg-red-500 .text-white,
        button.text-white[class*="bg-"],
        a.text-white[class*="bg-"] {
            color: #ffffff !important;
        }
        
        /* 3. Overlay tr√™n h√¨nh ·∫£nh (c√≥ gradient ƒëen) */
        [class*="from-black"] .text-white,
        [class*="bg-gradient-to-t"][class*="from-black"] .text-white,
        [class*="bg-black"] .text-white {
            color: #ffffff !important;
        }
        
        body[data-theme="dark"] section h1, 
        body[data-theme="dark"] section h2, 
        body[data-theme="dark"] section h3, 
        body[data-theme="dark"] section h4, 
        body[data-theme="dark"] section h5, 
        body[data-theme="dark"] section h6 {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        body[data-theme="dark"] {
            background: #1a202c;
            color: var(--color-text-light);
        }
        
        body[data-theme="dark"] .dark\:bg-gray-900 { background-color: #1a202c; }
        body[data-theme="dark"] .dark\:bg-gray-800 { background-color: #2d3748; }
        body[data-theme="dark"] .dark\:text-gray-100 { color: #f7fafc; }
        body[data-theme="dark"] .dark\:text-gray-300 { color: #d1d5db; }
        body[data-theme="dark"] .dark\:border-gray-700 { border-color: #4a5568; }

    </style>
</head>
<body class="min-h-screen" style="background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 50%, #fff9c4 100%);">
    <div class="min-h-screen flex flex-col">
        <header style="background: linear-gradient(135deg, #8bc34a 0%, #9ccc65 100%); box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div class="container mx-auto px-6 py-5 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
                <div>
                    <p class="text-sm uppercase tracking-widest text-white font-bold" style="letter-spacing: 0.2em; text-shadow: 2px 2px 6px rgba(0,0,0,0.4);">HC ECO SYSTEM</p>
                    <h1 class="text-3xl font-bold" style="color: #1b5e20; text-shadow: 3px 3px 8px rgba(255,255,255,0.5), 0 0 20px rgba(255,255,255,0.3);">B·∫£ng ƒêi·ªÅu Khi·ªÉn V√≤ng Quay</h1>
                </div>
                <div class="flex flex-wrap gap-3">
                    <a href="admin.html" class="px-5 py-2 rounded-lg bg-white text-green-700 font-bold hover:bg-green-50 transition shadow-md">
                        Quay v·ªÅ Admin
                    </a>
                    <button id="refresh-prizes" class="px-5 py-2 rounded-lg bg-yellow-400 text-green-900 font-bold hover:bg-yellow-300 transition shadow-md">
                        T·∫£i l·∫°i ph·∫ßn th∆∞·ªüng
                    </button>
                </div>
            </div>
        </header>

        <main class="flex-1 container mx-auto px-6 py-10">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <!-- Wheel Section - 2/3 width -->
                <section class="lg:col-span-2 rounded-3xl p-12 flex items-center justify-center" style="background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%); box-shadow: 0 10px 30px rgba(0,0,0,0.1); border: 2px solid #c5e1a5;">
                    <div class="relative flex items-center justify-center">
                        <div class="pointer" style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%);"></div>
                        <svg id="wheel-svg" viewBox="0 0 420 420" width="560" height="560" style="filter: drop-shadow(0 10px 25px rgba(0,0,0,0.15));">
                            <g id="wheel-graphic"></g>
                            <circle cx="210" cy="210" r="45" fill="#558b2f" stroke="#7cb342" stroke-width="5"></circle>
                            <text x="210" y="218" text-anchor="middle" fill="#ffffff" font-size="16" font-weight="bold" style="font-family: 'Times New Roman', Times, serif;">HC-ECO</text>
                        </svg>
                    </div>
                </section>

                <!-- Controls Section - 1/3 width -->
                <section class="rounded-3xl p-8 flex flex-col justify-center space-y-6" style="background: linear-gradient(135deg, #ffffff 0%, #f1f8e9 100%); box-shadow: 0 10px 30px rgba(0,0,0,0.1); border: 2px solid #c5e1a5;">
                    <div>
                        <h2 class="text-3xl font-bold mb-2" style="color: #1b5e20; text-shadow: 1px 1px 3px rgba(0,0,0,0.1);">V√≤ng Quay May M·∫Øn</h2>
                        <p class="text-base font-medium" style="color: #2e7d32;">Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu quay</p>
                    </div>
                    
                    <button id="spin-wheel-btn" class="spin-button w-full py-5 rounded-xl text-white text-xl font-bold">
                        Click chu·ªôt ho·∫∑c nh·∫•n Enter ƒë·ªÉ quay
                    </button>
                    
                    <div id="wheel-result" class="result-box rounded-2xl p-6 flex flex-col justify-center" style="display: none;">
                        <p class="text-sm uppercase tracking-widest mb-3 font-bold" style="color: #558b2f; letter-spacing: 0.2em;">PH·∫¶N TH∆Ø·ªûNG</p>
                        <div id="wheel-result-content" class="text-2xl font-bold" style="color: #33691e;"></div>
                    </div>
                    
                    <p class="text-sm text-center" style="color: #9e9e9e;">V√≤ng quay d√πng d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ tab "V√≤ng quay" trong Admin.</p>
                </section>
            </div>
        </main>
    </div>

    <script>
        const API_BASE = '../api';
        const DEFAULT_POINTER_ANGLE = 270;
        const wheelColors = ['#22c55e', '#6366f1', '#f97316', '#14b8a6', '#eab308', '#38bdf8', '#f43f5e', '#8b5cf6'];
        let wheelData = [];
        let wheelSegments = [];
        let currentRotation = 0;
        let isSpinning = false;

        document.addEventListener('DOMContentLoaded', () => {
            initWheelAdmin();
            document.getElementById('spin-wheel-btn').addEventListener('click', spinWheel);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !isSpinning) {
                    spinWheel();
                }
            });
            document.getElementById('refresh-prizes').addEventListener('click', fetchWheelPrizes);
        });

        async function initWheelAdmin() {
            const hasAccess = await checkAdminAccess();
            if (hasAccess) {
                fetchWheelPrizes();
            }
        }

        async function checkAdminAccess() {
            try {
                const url = API_BASE + '/check_admin_access.php?t=' + Date.now();
                const response = await fetch(url, { credentials: 'include' });
                const data = await response.json();
                if (!data.success || !data.has_access) {
                    window.location.href = 'login.html';
                    return false;
                }
                return true;
            } catch (error) {
                console.error('Admin check failed:', error);
                window.location.href = 'login.html';
                return false;
            }
        }

        async function fetchWheelPrizes() {
            try {
                const url = API_BASE + '/admin/get_wheel_prizes.php?status=active&t=' + Date.now();
                const response = await fetch(url, {
                    credentials: 'include'
                });
                const data = await response.json();
                if (!data.success) {
                    showResultMessage(data.message || 'Khong the tai phan thuong', true);
                    disableSpinButton(true);
                    return;
                }
                wheelData = data.data?.prizes || [];
                buildWheel(wheelData);
                disableSpinButton(wheelData.length === 0);
                
                const resultBox = document.getElementById('wheel-result');
                if (wheelData.length === 0) {
                    if (resultBox) resultBox.style.display = 'flex';
                    showResultMessage('Ch∆∞a c√≥ ph·∫ßn th∆∞·ªüng n√†o ho·∫°t ƒë·ªông. H√£y th√™m t·∫°i tab "V√≤ng quay" trong admin.', true);
                } else {
                    if (resultBox) resultBox.style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading wheel prizes:', error);
                showResultMessage('Khong the tai du lieu phan thuong.', true);
                disableSpinButton(true);
            }
        }

        function buildWheel(prizes) {
            const svgGroup = document.getElementById('wheel-graphic');
            if (!svgGroup) return;
            svgGroup.innerHTML = '';
            wheelSegments = [];

            if (prizes.length === 0) return;

            const sliceAngle = 360 / prizes.length;
            // Start from 0 degrees (3 o'clock position, pointing right)
            // Pointer is at 90 degrees (12 o'clock, pointing up)
            let startAngle = 0;

            prizes.forEach((prize, index) => {
                const endAngle = startAngle + sliceAngle;
                const color = wheelColors[index % wheelColors.length];

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', describeArc(210, 210, 180, startAngle, endAngle));
                path.setAttribute('fill', color);
                path.setAttribute('stroke', '#0f172a');
                path.setAttribute('stroke-width', '2');
                svgGroup.appendChild(path);

                const midAngle = startAngle + sliceAngle / 2;
                const textPoint = polarToCartesian(210, 210, 120, midAngle);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', textPoint.x);
                text.setAttribute('y', textPoint.y);
                text.setAttribute('fill', '#0f172a');
                text.setAttribute('font-size', '11');
                text.setAttribute('font-weight', '700');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('transform', 'rotate(' + midAngle + ' ' + textPoint.x + ' ' + textPoint.y + ')');
                text.textContent = prize.prize_name;
                svgGroup.appendChild(text);

                const rawWeight = Number(prize?.weight ?? prize?.chance ?? prize?.probability ?? prize?.win_rate);
                const segmentWeight = Number.isFinite(rawWeight) && rawWeight > 0 ? rawWeight : 1;

                wheelSegments.push({
                    prize,
                    startAngle,
                    endAngle,
                    midAngle,
                    weight: segmentWeight,
                });

                startAngle = endAngle;
            });
        }

        function renderPrizeList(prizes) {
            // Prize list removed - no longer needed in new layout
        }

        function normalizeAngle(angle) {
            return ((angle % 360) + 360) % 360;
        }

        function getPointerAngle() {
            const pointerElement = document.querySelector('.pointer');
            const wheelElement = document.getElementById('wheel-svg');
            if (!pointerElement || !wheelElement) {
                return DEFAULT_POINTER_ANGLE;
            }

            const wheelRect = wheelElement.getBoundingClientRect();
            const pointerRect = pointerElement.getBoundingClientRect();

            const centerX = wheelRect.left + wheelRect.width / 2;
            const centerY = wheelRect.top + wheelRect.height / 2;
            const pointerTipX = pointerRect.left + pointerRect.width / 2;
            const pointerTipY = pointerRect.bottom;

            const angle = Math.atan2(pointerTipY - centerY, pointerTipX - centerX) * 180 / Math.PI;
            return Number.isFinite(angle) ? normalizeAngle(angle) : DEFAULT_POINTER_ANGLE;
        }

        function selectWinningSegment(segments = wheelSegments) {
            if (!segments.length) return null;
            const totalWeight = segments.reduce((sum, segment) => sum + (segment.weight || 1), 0);
            let random = Math.random() * totalWeight;
            for (const segment of segments) {
                random -= segment.weight || 1;
                if (random <= 0) {
                    return segment;
                }
            }
            return segments[segments.length - 1];
        }

        function calculateRotationAmount(segment, extraSpins, pointerAngle) {
            const currentNormalized = normalizeAngle(currentRotation);
            const effectivePointerAngle = typeof pointerAngle === 'number' ? pointerAngle : DEFAULT_POINTER_ANGLE;
            const targetNormalized = normalizeAngle(effectivePointerAngle - segment.midAngle);
            const alignmentRotation = normalizeAngle(currentNormalized - targetNormalized);
            return extraSpins * 360 + alignmentRotation;
        }

        function spinWheel() {
            if (isSpinning || wheelSegments.length === 0) return;

            const wheelGraphic = document.getElementById('wheel-graphic');
            if (!wheelGraphic) {
                showResultMessage('Kh√¥ng t√¨m th·∫•y v√≤ng quay ƒë·ªÉ hi·ªÉn th·ªã.', true);
                return;
            }

            const pointerAngle = getPointerAngle();
            const segmentsSnapshot = wheelSegments.map(segment => ({ ...segment }));
            const winningSegment = selectWinningSegment(segmentsSnapshot);
            if (!winningSegment) {
                showResultMessage('Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c d·ªØ li·ªáu ph·∫ßn th∆∞·ªüng.', true);
                return;
            }

            isSpinning = true;
            disableSpinButton(true, 'ƒêang quay...');

            const extraSpins = 4 + Math.floor(Math.random() * 3);
            const rotationAmount = calculateRotationAmount(winningSegment, extraSpins, pointerAngle);
            currentRotation -= rotationAmount;
            wheelGraphic.style.transform = 'rotate(' + currentRotation + 'deg)';

            setTimeout(() => {
                isSpinning = false;
                disableSpinButton(false, 'Click chu·ªôt ho·∫∑c nh·∫•n Enter ƒë·ªÉ quay');
                
                const pointerSegment = getSegmentAtPointer(pointerAngle, segmentsSnapshot);
                let winnerSegment = pointerSegment || winningSegment;

                if (!winnerSegment && segmentsSnapshot.length) {
                    winnerSegment = segmentsSnapshot[0];
                }

                if (pointerSegment && winningSegment && pointerSegment !== winningSegment) {
                    console.warn('Wheel pointer mismatch detected', {
                        pointerAngle,
                        pointerSegment: pointerSegment.prize?.prize_name,
                        winningSegment: winningSegment.prize?.prize_name
                    });
                }

                if (winnerSegment && winnerSegment.prize) {
                    showWinnerResult(winnerSegment.prize);
                } else {
                    showResultMessage('Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ph·∫ßn th∆∞·ªüng. Vui l√≤ng quay l·∫°i.', true);
                }
            }, 4600);
        }
        
        function getSegmentAtPointer(pointerAngle = getPointerAngle(), segments = wheelSegments) {
            const activePointerAngle = typeof pointerAngle === 'number' ? pointerAngle : DEFAULT_POINTER_ANGLE;
            const segmentSource = Array.isArray(segments) && segments.length ? segments : wheelSegments;
            if (!segmentSource.length) return null;
            
            // Normalize current rotation to 0-360
            const normalizedRotation = normalizeAngle(currentRotation);
            // Determine which original angle now lies under the pointer
            const angleAtPointer = normalizeAngle(activePointerAngle - normalizedRotation);
            
            for (const segment of segmentSource) {
                let start = ((segment.startAngle % 360) + 360) % 360;
                let end = ((segment.endAngle % 360) + 360) % 360;
                
                if (start <= end) {
                    if (angleAtPointer >= start && angleAtPointer <= end) {
                        return segment;
                    }
                } else {
                    if (angleAtPointer >= start || angleAtPointer <= end) {
                        return segment;
                    }
                }
            }
            
            return null;
        }

        function showWinnerResult(prize) {
            const resultBox = document.getElementById('wheel-result');
            const resultArea = document.getElementById('wheel-result-content');
            if (!resultArea || !resultBox) return;
            
            resultBox.style.display = 'flex';
            resultBox.classList.remove('show-result');
            
            setTimeout(() => {
                if (!prize || !prize.prize_name) {
                    resultArea.innerHTML = '<span style="color: #f44336;">Kh√¥ng x√°c ƒë·ªãnh k·∫øt qu·∫£</span>';
                } else if (prize.prize_name.toLowerCase().includes('chuc may man') || 
                           prize.prize_name.toLowerCase().includes('ch√∫c may m·∫Øn')) {
                    resultArea.innerHTML = '<div style="text-align: center;"><div style="font-size: 1.8em; margin-bottom: 0.5em;">üòî</div>' +
                        '<div style="color: #ff9800; font-size: 1.3em;">Ch√∫c b·∫°n may m·∫Øn l·∫ßn sau!</div></div>';
                } else {
                    resultArea.innerHTML = '<div style="text-align: center;"><div style="font-size: 2em; margin-bottom: 0.5em;">üéâ</div>' +
                        '<div style="font-size: 1.5em; color: #558b2f; margin-bottom: 0.3em;">' + prize.prize_name + '</div>' +
                        '<div style="color: #7cb342; font-size: 1em;">Ch√∫c m·ª´ng b·∫°n ƒë√£ tr√∫ng th∆∞·ªüng!</div></div>';
                }
                resultBox.classList.add('show-result');
            }, 100);
        }

        function showResultMessage(message, isError = false) {
            const resultBox = document.getElementById('wheel-result');
            const resultArea = document.getElementById('wheel-result-content');
            if (!resultArea || !resultBox) return;
            
            resultBox.style.display = 'flex';
            resultBox.classList.remove('show-result');
            
            setTimeout(() => {
                resultArea.innerHTML = message;
                if (isError) {
                    resultArea.style.color = '#f44336';
                }
                resultBox.classList.add('show-result');
            }, 100);
        }

        function disableSpinButton(state, text) {
            const button = document.getElementById('spin-wheel-btn');
            if (!button) return;
            button.disabled = state;
            if (text) button.textContent = text;
            button.classList.toggle('opacity-60', state);
            button.classList.toggle('cursor-not-allowed', state);
        }

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            const angleInRadians = (angleInDegrees) * Math.PI / 180.0;
            return {
                x: centerX + radius * Math.cos(angleInRadians),
                y: centerY + radius * Math.sin(angleInRadians)
            };
        }

        function describeArc(x, y, radius, startAngle, endAngle) {
            const start = polarToCartesian(x, y, radius, endAngle);
            const end = polarToCartesian(x, y, radius, startAngle);
            const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';

            return [
                'M', x, y,
                'L', start.x, start.y,
                'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y,
                'Z'
            ].join(' ');
        }

    </script>

    <!-- Neural Network Canvas -->
    <canvas id="neural-network-canvas"></canvas>
    
    <script>
        // Neural Network Animation
        (function() {
            const canvas = document.getElementById('neural-network-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Node class
            class Node {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = (Math.random() - 0.5) * 0.5;
                    this.radius = Math.random() * 3 + 2;
                }
                
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Bounce off edges
                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                    
                    // Keep in bounds
                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }
                
                draw() {
                    // Draw node glow
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
                    gradient.addColorStop(0, 'rgba(134, 239, 172, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(74, 222, 128, 0.4)');
                    gradient.addColorStop(1, 'rgba(134, 239, 172, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw node core
                    ctx.fillStyle = 'rgba(74, 222, 128, 0.9)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Create nodes - tƒÉng s·ªë l∆∞·ª£ng n∆°-ron nhi·ªÅu h∆°n
            const nodeCount = 120;
            const nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                nodes.push(new Node(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
            
            // Connection distance threshold - tƒÉng kho·∫£ng c√°ch k·∫øt n·ªëi
            const connectionDistance = 180;
            
            // Animation loop
            function animate() {
                // Clear canvas with slight fade for trail effect
                ctx.fillStyle = 'rgba(249, 250, 251, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw connections
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < connectionDistance) {
                            const opacity = (1 - distance / connectionDistance) * 0.3;
                            ctx.strokeStyle = `rgba(74, 222, 128, ${opacity})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Update and draw nodes
                nodes.forEach(node => {
                    node.update();
                    node.draw();
                });
                
                requestAnimationFrame(animate);
            }
            
            // Start animation
            animate();
        })();
    </script>

</body>
</html>